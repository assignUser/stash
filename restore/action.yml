# Copyright (c) The stash contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
name: "Stash - restore"
description: "Restore you build cache stash."
author: assignUser

inputs:
  key:
    description: >
      Name of the artifact the stash is stored as. There is no `restore-key`
      functionality as there is no eviction (only expiry).

      The action checks the current branch for a stash, if there is no match,
      the base branch(PRs)/default branch is searched. If there is more than one
      match for any branch the most recently updated stash takes precedent.

      To reduce amount of api calls (1000/h/repo limit) the name of the
      current branch will be appended to the key. Key and branchname will be normalized.
    required: true

  path:
    description: 'A file, directory or wildcard pattern that describes what to upload'
    required: true
    default: ${{ github.workspace }}

  token:
    description: 'GITHUB_TOKEN to use to authenticate against the artifacts api.'
    default: ${{ github.token }}
    required: true
outputs:
  stash-hit:
    description: >
      A string ('true' or 'false') that indicates if a stash was restored or not. It is not
      possible to make this a boolean, as composite-action outputs are always strings. Sorry.
    value: ${{ steps.output.outputs.stash-hit }}

runs:
  using: 'composite'
  steps:
    - name: Check for dependencies
      shell: bash
      run: |
        function check_dep() {
          local cmd=$1
          $(type -P $cmd > /dev/null 2>&1) || { echo "::error ::$cmd is required for this action"; missing_dep=true; }
        }

        check_dep python3
        check_dep gh
        check_dep jq

        if [ "$missing_dep" == "true" ]; then
          exit 1
        fi

    - name: Mung Artifact Name
      id: mung
      shell: python3 {0}
      env:
        PYTHONPATH: "${{ github.action_path }}/../shared/"
        stash_key: "${{ inputs.key }}"
        stash_path: "${{ inputs.path }}"
        ref_name: "${{ github.ref_name }}"
        base_ref: "${{ github.base_ref || github.event.repository.default_branch }}"
      run: |
        import os
        import mung as m
        m.output_munged_name(output = 'stash_head')
        m.output_munged_name(ref = 'base_ref', output = 'stash_base')
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
          f.write(f'stash_path={os.path.abspath(os.environ["stash_path"])}' + '\n')

    - name: Check for stash artifact
      id: check-stash
      env:
        GH_TOKEN: "${{ inputs.token }}"
      shell: bash
      run: |
        function get_artifacts() {
          name=$1
          file=$2
          endpoint=${3:-'repos/${{ github.repository }}/actions/artifacts'}

          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -f name="$name" \
            -q '.artifacts | max_by(.updated_at | fromdate)' \
            --method=get \
            "$endpoint" > "$file"
        }

        # Check if an artifact with the same name has been uploaded in the current workflow.
        # Most recent hit by "updated_at" is used.
        get_artifacts '${{ steps.mung.outputs.stash_head }}' \
                      '/tmp/wf.json' \
                      'repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts'

        stash_name=$(jq -r '.name // empty' /tmp/wf.json)
        echo "::debug :: name=$stash_name"
        if [ -n "$stash_name" ]; then
          echo "stash_name=$stash_name" >> $GITHUB_OUTPUT
          echo 'stash_run_id=${{ github.run_id }}' >> $GITHUB_OUTPUT
          echo "Restoring $stash_name from this workflow run."
          exit 0
        fi

        echo "::debug ::Checking cross workflow"
        # Check across other workflow runs in the current branch.
        get_artifacts '${{ steps.mung.outputs.stash_head }}' \
                      '/tmp/branch.json'

        echo "::debug :: name=$stash_name"
        stash_name=$(jq -r '.name // empty' /tmp/branch.json)
        if [ -n "$stash_name" ]; then
          echo "stash_name=$stash_name" >> $GITHUB_OUTPUT
          echo "stash_run_id=$(jq '.workflow_run.id' /tmp/branch.json)" >> $GITHUB_OUTPUT
          echo "Restoring $stash_name from branch $(jq '.workflow_run.head_branch' /tmp/branch.json)."
          exit 0
        fi

        echo "::debug ::Checking in base branch"
        # Check on base/default branch.
        get_artifacts '${{ steps.mung.outputs.stash_base }}' \
                      '/tmp/base.json'

        echo "::debug :: name=$stash_name"
        stash_name=$(jq -r '.name // empty' /tmp/base.json)
        if [ -n "$stash_name" ]; then
          echo "stash_name=$stash_name" >> $GITHUB_OUTPUT
          echo "stash_run_id=$(jq '.workflow_run.id' /tmp/base.json)" >> $GITHUB_OUTPUT
          echo "Restoring $stash_name from branch $(jq '.workflow_run.head_branch' /tmp/base.json)."
          exit 0
        fi

        echo "stash_found=false" >> $GITHUB_OUTPUT

    - name: Download Stash
      shell: bash
      if: steps.check-stash.outputs.stash_found != 'false'
      id: download
      env:
        GH_TOKEN: "${{ inputs.token }}"
        STASH_NAME: "${{ steps.check-stash.outputs.stash_name }}"
        STASH_RUN_ID: "${{ steps.check-stash.outputs.stash_run_id }}"
      run: |
        gh run download $STASH_RUN_ID --name $STASH_NAME --dir "${{ steps.mung.outputs.stash_path }}"
        echo "Succesfully restored stash $STASH_NAME."


    - name: Set stash-hit Output
      id: output
      if: ${{ ! cancelled() }}
      shell: bash
      run: |
        if [ "${{ steps.download.conclusion }}" == "success" ]; then
          echo "stash-hit=true" >> $GITHUB_OUTPUT
        else
          echo "stash-hit=false" >> $GITHUB_OUTPUT
          echo "No stash found for keys ${{ steps.mung.outputs.stash_head }} or ${{ steps.mung.outputs.stash_base }}."
        fi
